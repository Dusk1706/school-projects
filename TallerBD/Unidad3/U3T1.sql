-- AGREGAR A LA TABLA PROVEEDORES EL CAMPO TOTALPIEZAS,
-- EL CUAL REPRESENTAR EL TOTAL DE PIEZAS VENDIDAS DE CADA PROVEEDOR.
-- CREAR UN PROCEDIMIENTO ALMACENADO QUE LLENE DICHO CAMPO.
-- CODIGO
ALTER TABLE SUPPLIERS
ADD TOTALPIEZAS INT
GO
CREATE PROC SP_PROVEEDORESTOTAL AS
BEGIN
	UPDATE SUPPLIERS
	SET TOTALPIEZAS = (
		SELECT SUM(QUANTITY)
		FROM VW_ORDERDETAILS AS OD
		WHERE OD.SUPPLIERID = SUPPLIERS.SUPPLIERID
		GROUP BY OD.SUPPLIERID
	)
END
GO
-- Ejecucion
EXEC SP_PROVEEDORESTOTAL
GO
-- Resultados
SELECT SUPPLIERID, TOTALPIEZAS FROM SUPPLIERS


GO
-- 2.- SP QUE RECIBA LA CLAVE DEL EMPLEADO Y REGRESE POR RETORNO LA EDAD EXACTA DEL EMPLEADO.
-- CODIGO
CREATE PROC SP_EMPLEADOEDAD (@EMPID INT) AS
BEGIN
		DECLARE @FECHA DATETIME, @EDAD INT
		SELECT @FECHA = BIRTHDATE FROM Employees WHERE EmployeeID=@EMPID
		SELECT @EDAD = DATEDIFF(YY,@FECHA,GETDATE())
		SELECT @FECHA=DATEADD(YY,@EDAD,@FECHA)
		IF @FECHA>GETDATE()
			SELECT @EDAD-=1
		RETURN @EDAD
END
GO
-- EJECUCION
DECLARE @EDADEMP10 INT
EXEC @EDADEMP10 = SP_EMPLEADOEDAD 10
-- RESULTADOS
SELECT @EDADEMP10 AS 'EDAD EMPLEADO 10'
GO

-- 3.- PROCEDIMIENTO ALMACENADO QUE RECIBA COMO PARAMETRO UN A�O Y REGRESE DOS PARAMETROS:
-- UN PARAMETRO CON EL NOMBRE DE TODOS LOS CLIENTES QUE COMPRARON ESE A�O
-- Y OTRO PARAMETRO CON LA LISTA DE LAS ORDENES REALIZADAS ESE A�O.

CREATE PROC SP_NOMBREORDENESANNO (@ANNO INT, @CLIENTES NVARCHAR(255) OUTPUT, @ORDENES NVARCHAR(255) OUTPUT) AS
BEGIN
	DECLARE @INDICE INT
	--Logica de clientes
	CREATE TABLE #TABLACLIENTES( ID INT IDENTITY(1,1), NOMBRE NVARCHAR(255) )
	INSERT INTO #TABLACLIENTES SELECT NOMCLIENTE FROM VW_ORDERDETAILS
	WHERE YEAR(ORDERDATE)=@ANNO GROUP BY NOMCLIENTE

	SELECT @INDICE = MIN(ID) FROM #TABLACLIENTES
	DECLARE @AUX NVARCHAR(255)
	SELECT @CLIENTES = NOMBRE FROM #TABLACLIENTES WHERE ID=@INDICE

	WHILE @INDICE IS NOT NULL
	BEGIN
		SELECT @INDICE = MIN(ID) FROM #TABLACLIENTES WHERE ID>@INDICE
		IF @INDICE IS NOT NULL
			SELECT @AUX = NOMBRE FROM #TABLACLIENTES WHERE ID=@INDICE
			SELECT @CLIENTES = CONCAT(@CLIENTES,', ',@AUX)
	END
	--Logica de ordenes
	SELECT @INDICE = MIN(ORDERID) FROM ORDERS WHERE YEAR(ORDERDATE)=@ANNO
	SELECT @ORDENES = CAST(@INDICE AS NVARCHAR(255))

	WHILE @INDICE IS NOT NULL
	BEGIN
		SELECT @INDICE = MIN(ORDERID) FROM ORDERS
		WHERE YEAR(ORDERDATE)=@ANNO AND ORDERID>@INDICE
		IF @INDICE IS NOT NULL
			SELECT @ORDENES = CONCAT(@ORDENES, ', ', @INDICE)
	END

	SELECT @CLIENTES = ISNULL(@CLIENTES, 'Ningun cliente compro este a�o')
	SELECT @ORDENES = ISNULL(@ORDENES, 'No hay ordenes este a�o')
END
GO
-- EJECUCION
DECLARE @CLIENTES VARCHAR(255),@ORDENES VARCHAR(255)
EXEC SP_NOMBREORDENESANNO 1996, @CLIENTES OUTPUT, @ORDENES OUTPUT
--RESULTADOS
SELECT @CLIENTES, @ORDENES
GO

-- 4.- PROCEDIMIENTO ALMACENADO QUE REGRESE UNA TABLA CON EL A�O Y
-- LOS NOMBRES DE LOS CLIENTES QUE SE COMPRARON ESE A�O.
CREATE PROC SP_CLIENTESANNO AS
BEGIN
	CREATE TABLE #RESULTADO(ANNO INT, CLIENTES NVARCHAR(255))
	--Logica para los a�os
    CREATE TABLE #ANNOS (ID INT IDENTITY(1,1), ANNO INT)
	INSERT INTO #ANNOS
	SELECT YEAR(ORDERDATE) FROM ORDERS
	GROUP BY YEAR(ORDERDATE)
	ORDER BY YEAR(ORDERDATE)


	DECLARE @INDICE INT, @ANNO INT
	SELECT @INDICE = MIN(ID) FROM #ANNOS
	SELECT @ANNO = ANNO FROM #ANNOS WHERE ID=@INDICE

	WHILE @INDICE IS NOT NULL
	BEGIN
		--Logica para nombre de clientes
		DECLARE @INDICECLI INT, @CLIENTES NVARCHAR(255), @AUX NVARCHAR(255)
		--Tabla con nombres
		CREATE TABLE #NOMBRES (ID INT IDENTITY(1,1), NOMBRE NVARCHAR(255))
		INSERT INTO #NOMBRES
		SELECT NOMCLIENTE FROM VW_ORDERDETAILS
		WHERE YEAR(ORDERDATE)=@ANNO
		GROUP BY NOMCLIENTE

		SELECT @INDICECLI = MIN(ID) FROM #NOMBRES
		SELECT @CLIENTES = NOMBRE FROM #NOMBRES
		WHILE @INDICECLI IS NOT NULL
		BEGIN
			SELECT @INDICECLI = MIN(ID) FROM #NOMBRES WHERE ID>@INDICECLI
			IF @INDICECLI IS NOT NULL
				SELECT @AUX = NOMBRE FROM #NOMBRES WHERE ID=@INDICECLI
				SELECT @CLIENTES = CONCAT(@CLIENTES, ', ', @AUX)
		END
		SELECT @CLIENTES = ISNULL(@CLIENTES,'Ningun cliente compro este a�o')
		INSERT INTO #RESULTADO VALUES(@ANNO,@CLIENTES)
		DROP TABLE #NOMBRES
		SELECT @INDICE = MIN(ID) FROM #ANNOS WHERE ID>@INDICE
		SELECT @ANNO = ANNO FROM #ANNOS WHERE ID=@INDICE
	END
	SELECT * FROM #RESULTADO
END
GO
--EJECUCION
EXEC SP_CLIENTESANNO

-- 5.- SP QUE RECIBA UN A�O Y REGRESE COMO PARAMETRO DE SALIDA LA CLAVE DEL ARTICULO
-- QUE MAS SE VENDIO ESE A�O Y CANTIDAD DE PIEZAS VENDIDAS DE ESE PRODUCTO EN ESE A�O.
ALTER PROC SP_ARTICULOANNO (@ANNO INT, @ARTID INT OUTPUT, @PIEZAS INT OUTPUT) AS
BEGIN
	SELECT TOP 1
		@ARTID=PRODUCTID, @PIEZAS=SUM(QUANTITY)
	FROM VW_ORDERDETAILS
	WHERE YEAR(ORDERDATE)=1996
	GROUP BY PRODUCTID
	ORDER BY SUM(QUANTITY) DESC
END
GO
--EJECUCION
DECLARE @ART INT, @PIEZ INT
EXEC SP_ARTICULOANNO 1996, @ART OUTPUT, @PIEZ OUTPUT
--RESULTADO
SELECT @ART AS ARTICULO, @PIEZ AS PIEZAS
GO

-- 6.- FUNCION DE TABLA DE MULTISENTENCIA QUE RECIBA UN A�O COMO PARAMETRO DE ENTRADA,
-- QUE REGRESE UNA TABLA CON DOS COLUMNAS: MES, FOLIOS QUE SE VENDIERON ESE MES.
-- NOTA: MOSTRAR TODOS LOS MESES.
CREATE OR ALTER FUNCTION dbo.ventasMes(@ANNO INT)
RETURNS @VENTAS TABLE (MES NVARCHAR(20), FOLIOS VARCHAR(255))
AS
BEGIN
	DECLARE @MESES TABLE(ID INT, MES VARCHAR(20))
	INSERT INTO @MESES VALUES
	(1,'ENERO'),(2,'FEBRERO'),(3,'MARZO'),(4,'ABRIL'),
	(5,'MAYO'),(6,'JUNIO'),(7,'JULIO'),(8,'AGOSTO'),
	(9,'SEPTIEMBRE'),(10,'OCTUBRE'),(11,'NOVIEMBRE'),(12,'DICIEMBRE')

	DECLARE @INDICE INT,@INDORDEN INT, @MESACTUAL NVARCHAR(20)
	SELECT @INDICE = MIN(ID) FROM @MESES
	SELECT @MESACTUAL=MES FROM @MESES WHERE ID=@INDICE

	--Mientras hay meses
	WHILE @INDICE IS NOT NULL
	BEGIN
		DECLARE @AUX VARCHAR(255)
		SELECT @INDORDEN = MIN(ORDERID)
		FROM ORDERS
		WHERE YEAR(ORDERDATE)=@ANNO AND MONTH(ORDERDATE)=@INDICE

		SELECT @AUX = @INDORDEN
		--Mientras hay ordenes
		WHILE @INDORDEN IS NOT NULL
		BEGIN
			SELECT @INDORDEN = MIN(ORDERID)
			FROM ORDERS
			WHERE
				YEAR(ORDERDATE)=@ANNO AND
				MONTH(ORDERDATE)=@INDICE AND
				ORDERID>@INDORDEN

			IF @INDORDEN IS NOT NULL
				SELECT @AUX = CONCAT(@AUX,',',@INDORDEN)
		END

		SELECT @MESACTUAL=MES FROM @MESES WHERE ID=@INDICE
		SELECT @AUX = ISNULL(@AUX,'No hubo ordenes')
		INSERT INTO @VENTAS VALUES(@MESACTUAL,@AUX)
		SELECT @INDICE = MIN(ID) FROM @MESES WHERE ID>@INDICE
	END
	RETURN
END
GO
--Resultado
SELECT * FROM dbo.ventasMes(1996)
GO
-- 7.- SP QUE RECIBA LA CLAVE DEL EMPLEADO Y REGRESE COMO PARAMETRO DE SALIDA
-- TODOS LOS NOMBRES DE LOS TERRITORIOS QUE ATIENDEN EL EMPLEADO.
CREATE PROC SP_TERRITORIOSEMP (@EMPID INT, @NOMBRES VARCHAR(255) OUTPUT)
AS
BEGIN
	SELECT
		@NOMBRES=STRING_AGG(RTRIM(TERRITORYDESCRIPTION), ', ')
	FROM VW_EMPLOYEETERRITORIES
	WHERE EMPLOYEEID=@EMPID
END
GO
--Resultado
DECLARE @TERRITORIOSEMP4 NVARCHAR(255)
EXEC SP_TERRITORIOSEMP 4, @TERRITORIOSEMP4 OUTPUT
SELECT @TERRITORIOSEMP4 AS Territorios
GO

-- 8.- SP QUE REALICE UN PROCESO DONDE REGRESE LA SIGUIENTE TABLA:
-- | NOMBRE DE EMPLEADO | Nombre de jefes | Jefe Superior |

CREATE SP_EMPLEADOJEFES AS
BEGIN
	DECLARE @TABLA TABLE (NOMEMP NVARCHAR(20), JEFES NVARCHAR(255), JEFESUPERIOR NVARCHAR(30))

	DECLARE @INDICE INT
	DECLARE @AUX NVARCHAR(255), @INDJEFE INT
	SELECT @INDICE = MIN(EMPLOYEEID) FROM EMPLOYEES

	--HAY EMPLEADOS
	WHILE @INDICE IS NOT NULL
	BEGIN
		DECLARE @NOMBREEMP NVARCHAR(20), @NOMBRESJEF NVARCHAR(255), @JEFESUPERIOR NVARCHAR(30)
		SELECT @INDJEFE = REPORTSTO FROM EMPLOYEES WHERE EMPLOYEEID=@INDICE
		SELECT @NOMBRESJEF = FIRSTNAME FROM EMPLOYEES WHERE EMPLOYEEID=@INDJEFE
		SELECT @JEFESUPERIOR = @NOMBRESJEF
		--HAY JEFES
		WHILE @INDJEFE IS NOT NULL
		BEGIN
			SELECT @INDJEFE = REPORTSTO FROM EMPLOYEES WHERE EMPLOYEEID=@INDJEFE
			IF @INDJEFE IS NOT NULL
			BEGIN
				SELECT @AUX=FIRSTNAME FROM EMPLOYEES WHERE EMPLOYEEID=@INDJEFE
				SELECT @NOMBRESJEF=CONCAT(@NOMBRESJEF, ', ', @AUX)
				SELECT @JEFESUPERIOR = @AUX
			END
		END

		SELECT @NOMBREEMP=FIRSTNAME FROM EMPLOYEES WHERE EMPLOYEEID=@INDICE
		IF @NOMBRESJEF IS NULL OR @NOMBRESJEF LIKE @NOMBREEMP
			SELECT @NOMBRESJEF='No hay un jefe superior'
		IF @JEFESUPERIOR IS NULL OR @JEFESUPERIOR LIKE @NOMBREEMP
			SELECT @JEFESUPERIOR='No hay un jefe superior'

		INSERT INTO @TABLA VALUES(@NOMBREEMP,@NOMBRESJEF,@JEFESUPERIOR)

		SELECT @INDICE = MIN(EMPLOYEEID) FROM EMPLOYEES WHERE EMPLOYEEID>@INDICE
	END
	SELECT * FROM @TABLA
END
GO
--RESULTADO
EXEC SP_EMPLEADOJEFES
GO
-- 9.- PROCEDIMIENTO ALMACENADO QUE RECIBA EL NOMBRE DE UNA TABLA Y QUE EL PROCEDIMIENTO IMPRIMA EL CODIGO DE CREACION DE DICHA TABLA.
CREATE OR ALTER PROCEDURE SP_CREARTABLA (@NOMTABLA NVARCHAR(100))
AS
BEGIN
    DECLARE @SQL NVARCHAR(4000)
    DECLARE @INDENT INT

    SET @SQL = 'CREATE TABLE ' + @NOMTABLA + ' (' +CHAR(13)
    SET @INDENT = 1

    SELECT @SQL = @SQL +
        CASE
            WHEN @SQL <> 'CREATE TABLE ' + @NOMTABLA + ' (' THEN CHAR(10) +
			REPLICATE('    ', @INDENT) ELSE ''
        END +
		C.NAME + ' ' +
        CASE
            WHEN T.NAME = 'NVARCHAR' THEN T.NAME + '(' + CASE WHEN C.MAX_LENGTH = -1
			THEN 'MAX' ELSE CAST(C.MAX_LENGTH / 2 AS NVARCHAR(10))
			END + ')'
            WHEN T.NAME IN ('CHAR', 'VARCHAR') THEN T.NAME + '(' +
		CASE
			WHEN C.MAX_LENGTH = -1 THEN 'MAX' ELSE CAST(C.MAX_LENGTH AS NVARCHAR(10))
		END + ')'
		WHEN T.NAME = 'DECIMAL' THEN T.NAME + '(' + CAST(C.PRECISION AS NVARCHAR(10))   + ', ' + CAST(C.SCALE AS NVARCHAR(10)) + ')'
            ELSE T.NAME
        END +
        CASE
            WHEN C.IS_NULLABLE = 0 THEN ' NOT NULL'
            ELSE ''
        END
    FROM SYS.COLUMNS C
    INNER JOIN SYS.TYPES T ON C.USER_TYPE_ID = T.USER_TYPE_ID
    WHERE OBJECT_ID = OBJECT_ID(@NOMTABLA)
    ORDER BY C.COLUMN_ID

    SET @SQL = UPPER(@SQL + CHAR(10) + ')')

    PRINT @SQL
END
GO

--Resultados
EXEC SP_CREARTABLA 'EMPLOYEES'
GO
-- 10.- PROCEDIMIENTO ALMACENADO QUE AUMENTE EL PRECIO DE LOS PRODUCTOS UN 10%
-- SI SE HAN VENDIDO MENOS DE UN IMPORTE DE $2,000, 25% ENTRE $2,001 Y $3,000, 30% MAS DE UN
-- IMPORTE DE $3,000.
CREATE OR ALTER PROC SP_AUMENTARPRECIO AS
BEGIN
	DECLARE @INDICE INT, @VENTA NUMERIC(12, 2)
	SELECT @INDICE = MIN(PRODUCTID) FROM PRODUCTS

	WHILE @INDICE IS NOT NULL
	BEGIN
		SELECT @VENTA = SUM(UNITPRICE * QUANTITY) FROM VW_ORDERDETAILS
		WHERE PRODUCTID = @INDICE
		IF @VENTA <= 2000
		BEGIN
			UPDATE PRODUCTS SET UNITPRICE = UNITPRICE * 1.1
			WHERE PRODUCTID = @INDICE
		END
		ELSE IF @VENTA <= 3000
		BEGIN
			UPDATE PRODUCTS SET UNITPRICE = UNITPRICE * 1.25
			WHERE PRODUCTID = @INDICE
		END
		ELSE
		BEGIN
			UPDATE PRODUCTS SET UNITPRICE = UNITPRICE * 1.3
			WHERE PRODUCTID = @INDICE
		END
		SELECT @INDICE = MIN(PRODUCTID) FROM PRODUCTS WHERE PRODUCTID > @INDICE
	END
END
GO


--Ejecucion
SELECT ProductID, ProductName, UnitPrice
FROM Products

EXEC SP_AUMENTARPRECIO

SELECT ProductID, ProductName, UnitPrice
FROM Products

